<script>
    class boundElement {
        constructor(element, owner, bindSelf, index) {
            this.stringBinders = [];
            this.repeatedElements = [];
            this.eventHandlers = [];
            this.element = element;
            this.owner = owner;
            this.index = index;

            this.initializeAttributeHandlers();

            if(bindSelf === true) {
                this.bindAttributes(element);
            }

            this.bindNodes();

            this.repeatedElements = this.repeatedElements.map((el) => new ooRepeatedElement(el, this.owner));
       
            this.eventHandlers.forEach((eh) => eh.element.removeAttribute(eh.attributeName));
            this.eventHandlers = null;
        }

        bindNodes() {
            let walker = this.buildTreeWalker(this.element);
            let currentNode;

            while(currentNode = walker.nextNode()){
                switch(currentNode.nodeType) {
                    case 3:
                        this.bindTextNode(currentNode);
                        break;
                    case 1:
                        this.bindAttributes(currentNode);
                        break;
                }
            }
        }

        buildTreeWalker(element) {
            let repeatedElements = this.repeatedElements;
            
            return document.createTreeWalker(
                element,
                NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT,
                {
                    acceptNode: function(node) {
                        if(node.nodeType == 1 && node.getAttribute('oo-rpt')) {
                            repeatedElements.push(node);
                            return NodeFilter.FILTER_REJECT;
                        }

                        switch(node.nodeName) {
                            case 'STYLE':
                            case 'SCRIPT':
                                return NodeFilter.FILTER_REJECT;
                            default:
                                return NodeFilter.FILTER_ACCEPT;
                        }   
                    }
                },
                false);
        }

        processStringBinder(stringBinder, item, index) {
            let stringModified = false;
                
            stringBinder.functions.forEach(function(func){
                let previousValue = stringBinder.strings[func.index];

                try { stringBinder.strings[func.index] = func.evalFunction(this.owner.state, item, index); }
                catch(err) { stringBinder.strings[func.index] = ""; }

                if(stringBinder.strings[func.index] !== previousValue)
                    stringModified = true;
            }, this);

            if(stringModified) {
                stringBinder.applyChange(stringBinder.strings.join(''));
            }
        }
 
        bindAttributes(element) {
            for(let i = 0; i < element.attributes.length; i++) {
                let handler = this.attributeHandlers[element.attributes[i].nodeName] || this.defaultAttributeHandler;
                
                handler.call(this, element, element.attributes[i]);
            }
        }

        bindTextNode(node) {
            this.createStringBinder(node.nodeValue,
            {
                node: node,
                applyChange: function(newString) {
                    this.node.nodeValue = newString;
                }
            });
        }

        createStringBinder(inputString, result, applyChange) {
            let match;
            let prevIndex = 0;
            let pattern = /{{\s*([^}]+)\s*}}/g;
            
            result.strings = [];
            result.functions = [];
            
            while(match = pattern.exec(inputString)) {

                if(match.index !== prevIndex) {
                    result.strings.push(inputString.substring(prevIndex, match.index));
                }
                
                result.strings.push(null);
                
                result.functions.push({
                    evalFunction: Function('state', 'item', 'index','return (' + match[1] + ');').bind(this.owner),
                    index: result.strings.length - 1
                });
                
                prevIndex = pattern.lastIndex;
            }

            if(result.functions.length > 0) { 
                
                if(prevIndex < inputString.length) {
                    result.strings.push(inputString.substring(prevIndex, inputString.length));
                }

                this.stringBinders.push(result);
            }
        }

        initializeAttributeHandlers() {
            this.attributeHandlers = {};

            this.attributeHandlers["oo-click"] = this.defaultEventBinder;
            this.attributeHandlers["oo-input"] = this.defaultEventBinder;
        }

        defaultAttributeHandler(element, attribute){
            this.createStringBinder(attribute.value,
                {
                    element: element,
                    attributeName: attribute.nodeName,
                    applyChange: function(newString) {
                        this.element.setAttribute(this.attributeName, newString);
                    }
                });
        }

        defaultEventBinder(element, attribute) {
            let evalFunction = Function('event', 'index', '(' + attribute.value + ')(event, index);').bind(this.owner);
            let eventAttr = attribute.nodeName.replace('oo-', 'on');
            element[eventAttr] = (e) => evalFunction(e, this.index); 

            this.eventHandlers.push({
                attributeName: attribute.nodeName,
                element: element
            });
        }

        refresh(item, index) {
            this.stringBinders.forEach((binder) => this.processStringBinder(binder, item, index));
            this.repeatedElements.forEach((rpt) => rpt.refresh(item, index));
        }
    }

    class ooRepeatedElement {
        constructor(element, owner) {
            let attrValue = element.getAttribute('oo-rpt');
            element.removeAttribute('oo-rpt');

            this.owner = owner;
            this.evalFunction = Function('state', 'item', 'index', 'return (' + attrValue + ');').bind(this.owner);
            this.template = element.cloneNode(true);
            this.parentNode = element.parentNode;
            this.nextSibling = element.nextSibling;
            this.prevLength = 0,
            this.rows = [{
                boundElement: new boundElement(element, this.owner, true, 0),
                isInserted: false
            }];
        }

        refresh(item) {
            let result = this.evalFunction(this.owner.state, item);
            
            result.forEach(function(arrayItem, index) {
                
                if(!this.rows[index]) {
                    this.rows[index] = {
                        boundElement: new boundElement(this.template.cloneNode(true), this.owner, true, index),
                        isInserted: false
                    };
                }

                this.rows[index].boundElement.refresh(arrayItem, index);

                if(!this.rows[index].isInserted) {
                    this.parentNode.insertBefore(this.rows[index].boundElement.element, this.nextSibling);
                    this.rows[index].isInserted = true;
                }
            }, this);

            if(result.length < this.prevLength) {
                for(let i = result.length; i < this.prevLength; i++) {
                    this.rows[i].boundElement.element.remove();
                    this.rows[i].isInserted = false;
                }
            }

            this.prevLength = result.length;
        }
    }

    class ooElement extends HTMLElement {
        constructor(template) {
            super(); // always call super() first in the ctor.

            if(template) {
                this.attachShadow({ mode: 'open' });
                this.shadowRoot.appendChild(template.content.cloneNode(true));
                this.boundRoot = new boundElement(this.shadowRoot, this);
            }
        }

        setState(data) {
            this.state = data;
            this.boundRoot.refresh();
        }
    }
</script>