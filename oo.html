<script>
    let debuggingEnabled = false;
    
    const textNodeRegEx = /{{\s*([^}]+)\s*}}/g;
    
    const stats = {
        numFunctionsCreated: 0,
        numFunctionCalls: 0,
        numUpdates: 0,
    };

    class binder {
        constructor(node, evalFunc) {
            this.node = node;
            this.evalFunc = evalFunc;
        }

        clearborder() {
            if(this.node.nodeType === 1) {
                this.node.style.border = "";
            }
        }

        hasChanged(newValue) {
            return newValue !== this.oldValue;
        }

        process(thisArg, context) {
            let newValue = '';
            stats.numFunctionCalls++;
            try { newValue = this.evalFunc.call(thisArg, context ? context.item : undefined, context); }
            catch(err) {}
            
            if(this.hasChanged(newValue)) {
                this.update(newValue, context);
                this.oldValue = newValue;
                stats.numUpdates++;                
            }
        }

        update(newValue, context) {
            if(this.node.nodeType === 1 && debuggingEnabled) {
                this.node.style.border = "thick solid #0000FF";
            }
        }
    }

    class attributeBinder extends binder {
        constructor(element, attributeName, evalFunc) {
            super(element, evalFunc);
            this.attributeName = attributeName;
        }

        update(newValue, context) {
            super.update(newValue, context);

            if(newValue === null || newValue === undefined || newValue === '')
                this.node.removeAttribute(this.attributeName);
            else
                this.node.setAttribute(this.attributeName, newValue);
        }
    }

    class textNodeBinder extends binder {
        constructor(textNode, evalFunc) {
            super(textNode, evalFunc);
            textNode.nodeValue = '';
        }

        update(newValue, context) {
            super.update(newValue, context);
            this.node.nodeValue = newValue;
        }
    }

    class propertyBinder extends binder {
        constructor(element, propertyName, evalFunc) {
            super(element, evalFunc);
            this.propertyName = propertyName;
        }

        update(newValue, context) {
            super.update(newValue, context);
            this.node[this.propertyName] = newValue;
        }
    }

    class showBinder extends binder {
        constructor(element, evalFunc) {
            super(element, evalFunc);
        }

        update(newValue, context) {
            super.update(newValue, context);
            this.node.style.display = newValue ? '' : 'none'; 
        }
    }

    class boundElement {
        constructor(element, owner, funcStore) {
            this.repeaters = [];
            this.binders = [];
            this.element = element;
            this.owner = owner;
            this.funcNum = 0;
            this.funcStore = funcStore || [];

            if(element.attributes)
                this.bindAttributes(element);

            this.bindNodes();
        }

        clearborder() {
            this.binders.forEach((binder) => binder.clearborder());
        }

        makeFuncFromString(evalStr) {
            if(this.funcStore[this.funcNum]) {
                return this.funcStore[this.funcNum++];
            }
            
            stats.numFunctionsCreated++;
            
            return this.funcStore[this.funcNum++] = new Function('item', 'context', 'return (' + evalStr + ');');
        }

        bindNodes() {
            let walker = this.buildTreeWalker(this.element);
            let currentNode;

            while(currentNode = walker.nextNode()){
                switch(currentNode.nodeType) {
                    case 3:
                        this.bindTextNodes(currentNode);
                        break;
                    case 1:
                        this.bindAttributes(currentNode);
                        break;
                }
            }

            this.binders = this.repeaters.concat(this.binders);

            for(let i = 0, len = this.repeaters.length; i < len; i++) {
                this.repeaters[i].initialize();
            }
        }

        buildTreeWalker(element) {
            let _this = this;

			function acceptNode(node) {
				switch(node.nodeType) {
					case 3:
						if(node.nodeValue.length < 5)
							return NodeFilter.FILTER_REJECT;
						
						return NodeFilter.FILTER_ACCEPT;
					case 1:
						switch(node.nodeName) {
							case 'STYLE':
							case 'SCRIPT':
								return NodeFilter.FILTER_REJECT;
							default:
								let rptAttr = node.getAttribute('oo-rpt');
								
								if(rptAttr) {
									_this.repeaters.push(new ooRptBinder(node, _this.makeFuncFromString(rptAttr), _this.owner));
									return NodeFilter.FILTER_REJECT;
								}
								
								return NodeFilter.FILTER_ACCEPT;
						}  
				}
			}
			
			// Work around Internet Explorer wanting a function instead of an object.
			// IE also *requires* this argument where other browsers don't.
			const safeFilter = acceptNode;
			safeFilter.acceptNode = acceptNode;
			
            return document.createTreeWalker(
                element,
                NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT,
                safeFilter,
                false);
        }

        bindTextNodes(node) {
            let match;
            let matches = [];

            while(match = textNodeRegEx.exec(node.nodeValue)) {
                matches.push({
                    evalText: match[1],
                    startIndex: match.index,
                    endIndex: textNodeRegEx.lastIndex
                });
            }
            
            // go backward, so as not to lose the reference for our original node
            for(let i = matches.length - 1, thisMatch; i >= 0; i--)
            {
                thisMatch = matches[i];
                
                // if the end of our match is not the end of the text node, cut off the end
                if(node.nodeValue.length > thisMatch.endIndex)
                    node.splitText(thisMatch.endIndex);
                
                // if we are not at the beginning of the text node, split it, so our bound text node
                // starts right at the binding point
                this.binders.push(
                    new textNodeBinder(
                        thisMatch.startIndex != 0 ? node.splitText(thisMatch.startIndex) : node, 
                        this.makeFuncFromString(thisMatch.evalText)
                    )
                );
            }
        }
 
        bindAttributes(element) {
            let attr;
            let attrName;
            let realName;
            let currentBinder;

            for(let i = element.attributes.length - 1; i >= 0; i--) {
                attr = element.attributes[i];
                attrName = attr.name;
                
                if(attrName == 'oo-show') {
                    this.binders.push(new showBinder(element, attr.value));
                    element.removeAttribute(attrName);
                    continue;
                }   

                if(attrName[0] === '[' && attrName[attrName.length - 1] === ']') {
                    
                    realName = attrName.substring(1, attrName.length - 1);
                    
                    currentBinder = realName in element ? propertyBinder : attributeBinder;
                    
                    this.binders.push(
                        new currentBinder(
                            element, 
                            realName, 
                            this.makeFuncFromString(attr.value)
                        )
                    );

                    element.removeAttribute(attrName);
                }
            }
        }

        refresh(context) {
            context = context || {};
            context.binder = this;

            for(let i = 0, len = this.binders.length; i < len; i++) {
                this.binders[i].process(this.owner, context || { binder: this });
            }
        }

        getStats() {
            return stats;
        }

        resetStats() {
            stats.numFunctionsCreated = 0;
            stats.numFunctionCalls = 0;
            stats.numUpdates = 0;
        }
    }

    class ooRptBinder extends binder {
        constructor(element, evalFunc, owner) {
            super(element, evalFunc);
            element.removeAttribute('oo-rpt');

            this.owner = owner;
            this.parentNode = element.parentNode;
            this.nextSibling = element.nextSibling;
            this.prevLength = 0,
            this.rows = [];
            this.funcStore = [];
        }

        initialize() {
            this.nextSibling = document.createComment("oo-rpt");
            this.parentNode.insertBefore(this.nextSibling, this.node.nextSibling);
            this.node.remove();
        }

        clearborder() {
            super.clearborder();
            this.rows.forEach((binder) => binder.clearborder());
        }

        hasChanged(newValue) {
            return true;
        }

        update(newValue, context) {
            //super.update(newValue, context);

            let newLength = newValue.length;
            let rowsLength = this.rows.length;
            let currentRow;

            for(let i = 0; i < newLength; i++) {
                if(i >= rowsLength)
                    this.rows[i] = new boundElement(this.node.cloneNode(true), this.owner, this.funcStore);

                currentRow = this.rows[i];

                currentRow.refresh({
                    parent: context,
                    item: newValue[i],
                    index: i,
                    binder: currentRow
                });

                if(i >= this.prevLength) {
                    this.parentNode.insertBefore(currentRow.element, this.nextSibling);
                }
            }

            if(newLength < this.prevLength) {
                for(let i = newLength; i < this.prevLength; i++) {
                    this.rows[i].element.remove();
                }
            }

            this.prevLength = newLength;
        }
    }

    class ooElement extends HTMLElement {
        constructor(template) {
            super(); // always call super() first in the ctor.

            if(template) {
                this.attachShadow({ mode: 'open' });
                this.shadowRoot.appendChild(template.content.cloneNode(true));
                this.boundRoot = new boundElement(this.shadowRoot, this);
            }
        }
    }
</script>