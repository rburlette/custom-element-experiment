<script>
    class binder {
        constructor(evalFunc) {
            this.evalFunc = evalFunc;
            this.newValue = '';
        }

        process(thisArg, context) {
            try {
                this.newValue = this.evalFunc.call(thisArg, thisArg.state, context.item, context);
            }
            catch(err) {
                this.newValue = '';
            }
                
            this.update();
        }

        update() {}
    }

    class attributeBinder extends binder {
        constructor(element, attributeName, evalFunc) {
            super(evalFunc);
            this.element = element;
            this.attributeName = attributeName;
        }

        update() {
            if(this.newValue === null || this.newValue === undefined || this.newValue === '')
                this.element.removeAttribute(this.attributeName);
            else
                this.element.setAttribute(this.attributeName, this.newValue);
        }
    }

    class textNodeBinder extends binder {
        constructor(textNode, evalFunc) {
            super(evalFunc);
            this.textNode = textNode;
        }

        update() {
            if(this.textNode.nodeValue !== this.newValue) {
                this.textNode.nodeValue = this.newValue;
            }
        }
    }

    class propertyBinder extends binder {
        constructor(element, propertyName, evalFunc) {
            super(evalFunc);
            this.element = element;
            this.propertyName = propertyName;
        }

        update() {
            this.element[this.propertyName] = this.newValue;
        }
    }

    class showBinder extends binder {
        constructor(element, evalFunc) {
            super(evalFunc);
            this.element = element;
        }

        update() {
            if(this.newValue)
                this.element.style.display = '';
            else
                this.element.style.display = 'none';
        }
    }

    class boundElement {
        constructor(element, owner) {
            this.binders = [];

            this.repeatedElements = [];
            this.element = element;
            this.owner = owner;
            this.context = {};

            this.bindAttributes(element);

            this.bindNodes();

            this.repeatedElements = this.repeatedElements.map((el) => new ooRepeatedElement(el, this.owner));
        }

        bindNodes() {
            let walker = this.buildTreeWalker(this.element);
            let currentNode;

            while(currentNode = walker.nextNode()){
                switch(currentNode.nodeType) {
                    case 3:
                        this.generateMatchArray(currentNode);
                        break;
                    case 1:
                        this.bindAttributes(currentNode);
                        break;
                }
            }
        }

        buildTreeWalker(element) {
            let repeatedElements = this.repeatedElements;
            
            return document.createTreeWalker(
                element,
                NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT,
                {
                    acceptNode: function(node) {
                        if(node.nodeType == 1 && node.getAttribute('oo-rpt')) {
                            repeatedElements.push(node);
                            return NodeFilter.FILTER_REJECT;
                        }

                        switch(node.nodeName) {
                            case 'STYLE':
                            case 'SCRIPT':
                                return NodeFilter.FILTER_REJECT;
                            default:
                                return NodeFilter.FILTER_ACCEPT;
                        }   
                    }
                },
                false);
        }

        generateMatchArray(node) {
            let match;
            let lastIndex = 0;
            let pattern = /{{\s*([^}]+)\s*}}/g;
            let matches = [];

            while(match = pattern.exec(node.nodeValue)) {
                matches.push({
                    func: this.funcFromString(match[1]),
                    index: match.index,
                    end: match.index + match[0].length
                });
            }
            
            if(matches.length == 0)
                return null;

            for(let i = matches.length - 1; i >= 0; i-- )
            {
                if(node.nodeValue.length > matches[i].end) {
                    node.splitText(matches[i].end);
                }
                
                if(matches[i].index != 0) {
                    matches[i].node = node.splitText(matches[i].index);
                } else {
                    matches[i].node = node;
                } 

                matches[i].node.nodeValue = '';  

                this.binders.push(new textNodeBinder(matches[i].node, matches[i].func));
            }

            return matches;
        }

        funcFromString(str) {
            return Function('state', 'item', 'context', 'return (' + str + ');');
        }
 
        bindAttributes(element) {
            if(!element.attributes)
                return;
            
            let attr;
            let attrName;
            let realName;
            let currentBinder;

            for(let i = element.attributes.length - 1; i >= 0; i--) {
                attr = element.attributes[i];
                attrName = attr.name;
                
                if(attrName == 'oo-show') {
                    this.binders.push(new showBinder(element, this.funcFromString(attr.value)));
                    element.removeAttribute(attrName);
                    continue;
                }   
                

                if(attrName[0] === '[' && attrName[attrName.length - 1] === ']') {
                    
                    realName = attrName.substring(1, attrName.length - 1);
                    
                    currentBinder = realName in element ? propertyBinder : attributeBinder;
                    
                    this.binders.push(
                        new currentBinder(
                            element, 
                            attrName.substring(1, attrName.length - 1), 
                            this.funcFromString(attr.value)
                        )
                    );

                    element.removeAttribute(attrName);
                }
            }
        }

        refresh(context) {
             this.context = context;
             this.evalCount = 0;

            for(let i = 0; i < this.repeatedElements.length; i++) {
                this.evalCount += this.repeatedElements[i].refresh(this.context);
            }

            for(let i = 0, len = this.binders.length; i < len; i++) {
                this.binders[i].process(this.owner, this.context);
            }

            return this.evalCount;
        }
    }

    class ooRepeatedElement {
        constructor(element, owner) {
            let attrValue = element.getAttribute('oo-rpt');
            element.removeAttribute('oo-rpt');

            this.owner = owner;
            this.evalFunction = Function('state', 'item', 'context', 'return (' + attrValue + ');').bind(this.owner);
            this.template = element.cloneNode(true);
            this.parentNode = element.parentNode;
            this.nextSibling = element.nextSibling;
            this.prevLength = 0,
            this.rows = [{
                boundElement: new boundElement(element, this.owner, true, 0),
                isInserted: false
            }];
        }

        refresh(parentContext) {
            this.evalCount = 1;
            
            let item = parentContext ? parentContext.item : null;
            let result = this.evalFunction(this.owner.state, item, parentContext);
            
            for(let i = 0; i < result.length; i++) {
                if(!this.rows[i]) {
                    this.rows[i] = {
                        boundElement: new boundElement(this.template.cloneNode(true), this.owner, true, i),
                        isInserted: false
                    };
                }

                this.evalCount += this.rows[i].boundElement.refresh({
                    parent: parentContext,
                    item: result[i],
                    index: i
                });

                if(!this.rows[i].isInserted) {
                    this.parentNode.insertBefore(this.rows[i].boundElement.element, this.nextSibling);
                    this.rows[i].isInserted = true;
                }
            }

            if(result.length < this.prevLength) {
                for(let i = result.length; i < this.prevLength; i++) {
                    this.rows[i].boundElement.element.remove();
                    this.rows[i].isInserted = false;
                }
            }

            this.prevLength = result.length;
            
            return this.evalCount;
        }
    }

    class ooElement extends HTMLElement {
        constructor(template) {
            super(); // always call super() first in the ctor.

            if(template) {
                this.attachShadow({ mode: 'open' });
                this.shadowRoot.appendChild(template.content.cloneNode(true));
                this.boundRoot = new boundElement(this.shadowRoot, this);
            }
        }

        setState(data) {
            this.state = data;
            this.boundRoot.refresh();
        }
    }
</script>