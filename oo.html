<script>
    const textNodeRegEx = /{{\s*([^}]+)\s*}}/g;

    class binder {
        constructor(node, evalStr) {
            this.node = node;
            this.evalFunc = Function('item', 'context', 'return (' + evalStr + ');');
        }

        hasChanged(newValue) {
            return newValue !== this.oldValue;
        }

        process(thisArg, context) {
            let newValue = '';

            try { newValue = this.evalFunc.call(thisArg, context ? context.item : undefined, context); }
            catch(err) {}
            
            if(this.hasChanged(newValue)) {
                this.update(newValue, context);
                this.oldValue = newValue;                
            }
        }

        update(newValue, context) {}
    }

    class attributeBinder extends binder {
        constructor(element, attributeName, evalFunc) {
            super(element, evalFunc);
            this.attributeName = attributeName;
        }

        update(newValue, context) {
            if(newValue === null || newValue === undefined || newValue === '')
                this.node.removeAttribute(this.attributeName);
            else
                this.node.setAttribute(this.attributeName, newValue);
        }
    }

    class textNodeBinder extends binder {
        constructor(textNode, evalFunc) {
            super(textNode, evalFunc);
            textNode.nodeValue = '';
        }

        update(newValue, context) {
            this.node.nodeValue = newValue;
        }
    }

    class propertyBinder extends binder {
        constructor(element, propertyName, evalFunc) {
            super(element, evalFunc);
            this.propertyName = propertyName;
        }

        update(newValue, context) {
            this.node[this.propertyName] = newValue;
        }
    }

    class showBinder extends binder {
        constructor(element, evalFunc) {
            super(element, evalFunc);
        }

        update(newValue, context) {
            this.node.style.display = newValue ? '' : 'none'; 
        }
    }

    class boundElement {
        constructor(element, owner) {
            this.repeaters = [];
            this.binders = [];
            this.element = element;
            this.owner = owner;

            if(element.attributes)
                this.bindAttributes(element);

            this.bindNodes();
        }

        bindNodes() {
            let walker = this.buildTreeWalker(this.element);
            let currentNode;

            while(currentNode = walker.nextNode()){
                switch(currentNode.nodeType) {
                    case 3:
                        this.bindTextNodes(currentNode);
                        break;
                    case 1:
                        this.bindAttributes(currentNode);
                        break;
                }
            }

            this.binders = this.repeaters.concat(this.binders);
            for(let i = 0, len = this.repeaters.length; i < len; i++) {
                this.repeaters[i].node.remove();
            }
        }

        buildTreeWalker(element) {
            let owner = this.owner;
            let repeaters = this.repeaters;
            return document.createTreeWalker(
                element,
                NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT,
                {
                    acceptNode: function(node) {
                        if(node.nodeType == 1 && node.hasAttribute('oo-rpt')) {
                            repeaters.push(new ooRptBinder(node, owner));
                            return NodeFilter.FILTER_REJECT;
                        }

                        if(node.nodeType == 3 && node.nodeValue.length < 5)
                            return NodeFilter.FILTER_REJECT;

                        switch(node.nodeName) {
                            case 'STYLE':
                            case 'SCRIPT':
                                return NodeFilter.FILTER_REJECT;
                            default:
                                return NodeFilter.FILTER_ACCEPT;
                        }   
                    }
                },
                false);
        }

        bindTextNodes(node) {
            let match;
            let matches = [];

            while(match = textNodeRegEx.exec(node.nodeValue)) {
                matches.push({
                    evalText: match[1],
                    startIndex: match.index,
                    endIndex: textNodeRegEx.lastIndex
                });
            }
            
            // go backward, so as not to lose the reference for our original node
            for(let i = matches.length - 1, thisMatch; i >= 0; i--)
            {
                thisMatch = matches[i];
                
                // if the end of our match is not the end of the text node, cut off the end
                if(node.nodeValue.length > thisMatch.endIndex)
                    node.splitText(thisMatch.endIndex);
                
                // if we are not at the beginning of the text node, split it, so our bound text node
                // starts right at the binding point
                this.binders.push(
                    new textNodeBinder(
                        thisMatch.startIndex != 0 ? node.splitText(thisMatch.startIndex) : node, 
                        thisMatch.evalText
                    )
                );
            }
        }
 
        bindAttributes(element) {
            let attr;
            let attrName;
            let realName;
            let currentBinder;

            for(let i = element.attributes.length - 1; i >= 0; i--) {
                attr = element.attributes[i];
                attrName = attr.name;
                
                if(attrName == 'oo-show') {
                    this.binders.push(new showBinder(element, attr.value));
                    element.removeAttribute(attrName);
                    continue;
                }   

                if(attrName[0] === '[' && attrName[attrName.length - 1] === ']') {
                    
                    realName = attrName.substring(1, attrName.length - 1);
                    
                    currentBinder = realName in element ? propertyBinder : attributeBinder;
                    
                    this.binders.push(
                        new currentBinder(
                            element, 
                            realName, 
                            attr.value
                        )
                    );

                    element.removeAttribute(attrName);
                }
            }
        }

        refresh(context) {
            for(let i = 0, len = this.binders.length; i < len; i++) {
                this.binders[i].process(this.owner, context);
            }
        }
    }

    class ooRptBinder extends binder {
        constructor(element, owner) {
            super(element, element.getAttribute('oo-rpt'));
            element.removeAttribute('oo-rpt');

            this.owner = owner;
            this.parentNode = element.parentNode;
            this.nextSibling = element.nextSibling;
            this.prevLength = 0,

            this.rows = [];
        }

        hasChanged(newValue) {
            return true;
        }

        update(newValue, context) {
            let newLength = newValue.length;
            let rowsLength = this.rows.length;
            let currentRow;

            for(let i = 0; i < newLength; i++) {
                if(i >= rowsLength)
                    this.rows[i] = new boundElement(this.node.cloneNode(true), this.owner);

                currentRow = this.rows[i];

                currentRow.refresh({
                    parent: context,
                    item: newValue[i],
                    index: i
                });

                if(i >= this.prevLength) {
                    this.parentNode.insertBefore(currentRow.element, this.nextSibling);
                }
            }

            if(newLength < this.prevLength) {
                for(let i = newLength; i < this.prevLength; i++) {
                    this.rows[i].element.remove();
                }
            }

            this.prevLength = newLength;
        }
    }

    class ooElement extends HTMLElement {
        constructor(template) {
            super(); // always call super() first in the ctor.

            if(template) {
                this.attachShadow({ mode: 'open' });
                this.shadowRoot.appendChild(template.content.cloneNode(true));
                this.boundRoot = new boundElement(this.shadowRoot, this);
            }
        }
    }
</script>