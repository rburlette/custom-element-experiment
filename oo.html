<script>
    class ooElement extends HTMLElement {
        constructor(template) {
            super(); // always call super() first in the ctor.

            if(template) {
                var shadowRoot = this.createShadow(template);

                this.initialize(shadowRoot);
            }
        }

        createShadow(tmpl) {
            if(!tmpl)
                return null;
            
            let shadowRoot = this.attachShadow({ mode: 'open' });
            shadowRoot.appendChild(tmpl.content.cloneNode(true));

            return shadowRoot;
        }

        setState(data) {
            this.state = data;

            this.stringBinders.forEach(this.processStringBinder);
        }

        initialize(shadowRoot) {
            this.stringBinders = [];

            let currentNode;

            let walker = document.createTreeWalker(
                shadowRoot,
                NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT,
                {
                    acceptNode: function(node) {
                        if(node.nodeType === 3) {
                            
                            // skip node if there are no non whitespace chars
                            if (!(/\S/.test(node.nodeValue))) {
                                return NodeFilter.FILTER_SKIP;
                            }
                        }
                        else {
                            // do not process style or script nodes
                            switch(node.nodeName) {
                                case 'STYLE':
                                case 'SCRIPT':
                                    return NodeFilter.FILTER_REJECT;
                            }   

                            // if there are no attributes, skip
                            if(node.attributes.length === 0)
                                return NodeFilter.FILTER_SKIP;                        
                        }

                        return NodeFilter.FILTER_ACCEPT;
                    }
                },
                false);

            while(currentNode = walker.nextNode()){

                if(currentNode.nodeType === 3) {
                    let result = this.createStringBinder(currentNode.nodeValue);

                    if(result !== null) {
                        result.node = currentNode;

                        result.applyChange = function(newString) {
                            this.node.nodeValue = newString;
                        };

                        result.applyChange.bind(result);

                        this.stringBinders.push(result);
                    }
                }
                else if(currentNode.nodeType === 1) {
                    for(let i = 0; i < currentNode.attributes.length; i++) {

                        let result = this.createStringBinder(currentNode.attributes[i].value);
                        if(result !== null){
                            result.element = currentNode;
                            result.attributeName = currentNode.attributes[i].nodeName;

                            result.applyChange = function(newString) {
                                this.element.setAttribute(this.attributeName, newString);
                            };

                            result.applyChange.bind(result);
                            this.stringBinders.push(result);
                        }  
                    }
                }

            }
        }

        processStringBinder(stringBinder) {
            let stringModified = false;
                
            stringBinder.functions.forEach(function(func){
                let previousValue = stringBinder.strings[func.index];

                try {
                    stringBinder.strings[func.index] = func.evalFunction();
                }
                catch(err) {
                    stringBinder.strings[func.index] = "";
                }

                if(stringBinder.strings[func.index] !== previousValue)
                    stringModified = true;
            });

            if(stringModified) {
                stringBinder.applyChange(stringBinder.strings.join(''));
            }
        }

        createStringBinder(inputString) {
            let match;
            let prevIndex = 0;
            let pattern = /{{\s*([^}]+)\s*}}/g;
            
            let result = {
                strings: [],
                functions: []
            };
            
            while(match = pattern.exec(inputString)) {

                if(match.index !== prevIndex) {
                    result.strings.push(inputString.substring(prevIndex, match.index));
                }
                
                result.strings.push(null);
                
                result.functions.push({
                    evalFunction: Function('return (' + match[1] + ');').bind(this),
                    index: result.strings.length - 1
                });
                
                prevIndex = pattern.lastIndex;
            }

            if(result.functions.length === 0)
                return null;

            if(prevIndex < inputString.length) {
                result.strings.push(inputString.substring(prevIndex, inputString.length));
            }

            return result;
        }
    }
</script>