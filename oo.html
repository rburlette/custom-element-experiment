<script>
    class boundElement {
        constructor(element, owner) {
            this.evalCount = 0;
            this.stringBinders = [];
            this.repeatedElements = [];
            this.eventHandlers = [];
            this.element = element;
            this.owner = owner;
            this.context = null;

            this.initializeAttributeHandlers();

            this.bindAttributes(element);

            this.bindNodes();

            this.repeatedElements = this.repeatedElements.map((el) => new ooRepeatedElement(el, this.owner));
       
            for(let i = 0, len = this.eventHandlers.length; i < len; i++) {
                this.eventHandlers[i].element.removeAttribute(this.eventHandlers[i].attributeName);
            }

            this.eventHandlers = null;
        }

        bindNodes() {
            let walker = this.buildTreeWalker(this.element);
            let currentNode;

            while(currentNode = walker.nextNode()){
                switch(currentNode.nodeType) {
                    case 3:
                        this.bindTextNode(currentNode);
                        break;
                    case 1:
                        this.bindAttributes(currentNode);
                        break;
                }
            }
        }

        buildTreeWalker(element) {
            let repeatedElements = this.repeatedElements;
            
            return document.createTreeWalker(
                element,
                NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT,
                {
                    acceptNode: function(node) {
                        if(node.nodeType == 1 && node.getAttribute('oo-rpt')) {
                            repeatedElements.push(node);
                            return NodeFilter.FILTER_REJECT;
                        }

                        switch(node.nodeName) {
                            case 'STYLE':
                            case 'SCRIPT':
                                return NodeFilter.FILTER_REJECT;
                            default:
                                return NodeFilter.FILTER_ACCEPT;
                        }   
                    }
                },
                false);
        }

        processStringBinder(stringBinder) {
            let stringModified = false;
            let funcData = null;
            let index = null;
            let previousValue = null;

            for(let i = 0, len = stringBinder.functions.length; i < len; i++) {
                funcData = stringBinder.functions[i];
                index = funcData.index;

                previousValue = stringBinder.strings[index];
                this.evalCount += 1;
                try { stringBinder.strings[index] = funcData.evalFunction(this.owner.state, this.context.item, this.context); }
                catch(err) { stringBinder.strings[index] = ""; }

                if(stringBinder.strings[index] !== previousValue)
                    stringModified = true;
            }

            if(stringModified) {
                stringBinder.applyChange(stringBinder.strings.join(''));
            }
        }
 
        bindAttributes(element) {
            if(!element.attributes)
                return;

            for(let i = 0; i < element.attributes.length; i++) {
                let handler = this.attributeHandlers[element.attributes[i].nodeName] || this.defaultAttributeHandler;
                
                handler.call(this, element, element.attributes[i]);
            }
        }

        bindTextNode(node) {
            this.createStringBinder(node.nodeValue,
            {
                node: node,
                applyChange: function(newString) {
                    this.node.nodeValue = newString;
                }
            });
        }

        createStringBinder(inputString, result, applyChange) {
            let match;
            let prevIndex = 0;
            let pattern = /{{\s*([^}]+)\s*}}/g;
            
            result.strings = [];
            result.functions = [];
            
            while(match = pattern.exec(inputString)) {

                if(match.index !== prevIndex) {
                    result.strings.push(inputString.substring(prevIndex, match.index));
                }
                
                result.strings.push(null);
                
                result.functions.push({
                    evalFunction: Function('state', 'item', 'context','return (' + match[1] + ');').bind(this.owner),
                    index: result.strings.length - 1
                });
                
                prevIndex = pattern.lastIndex;
            }

            if(result.functions.length > 0) { 
                
                if(prevIndex < inputString.length) {
                    result.strings.push(inputString.substring(prevIndex, inputString.length));
                }

                this.stringBinders.push(result);
            }
        }

        initializeAttributeHandlers() {
            this.attributeHandlers = {};

            this.attributeHandlers["oo-click"] = this.defaultEventBinder;
            this.attributeHandlers["oo-input"] = this.defaultEventBinder;
        }

        defaultAttributeHandler(element, attribute){
            this.createStringBinder(attribute.value,
                {
                    element: element,
                    attributeName: attribute.nodeName,
                    applyChange: function(newString) {
                        switch(newString) {
                            case '': 
                                this.element.removeAttribute(this.attributeName);
                                break;
                            case this.attributeName:
                                this.element.setAttribute(this.attributeName, '');
                                break;
                            default: 
                                this.element.setAttribute(this.attributeName, newString);
                                break;
                        }
                    }
                });
        }

        defaultEventBinder(element, attribute) {
            let evalFunction = Function('event', 'item', 'context', '(' + attribute.value + ')(event, item, context);').bind(this.owner);
            let eventAttr = attribute.nodeName.replace('oo-', 'on');
            let item = this.context ? this.context.item : this.context;
            element[eventAttr] = (e) => evalFunction(e, item, this.context); 

            this.eventHandlers.push({
                attributeName: attribute.nodeName,
                element: element
            });
        }

        refresh(context) {
            this.evalCount = 0;
            this.context = context;

            for(let i = 0; i < this.stringBinders.length; i++) {
                this.processStringBinder(this.stringBinders[i]);
            }
            
            for(let i = 0; i < this.repeatedElements.length; i++) {
                this.evalCount += this.repeatedElements[i].refresh(this.context);
            }

            return this.evalCount;
        }
    }

    class ooRepeatedElement {
        constructor(element, owner) {
            let attrValue = element.getAttribute('oo-rpt');
            element.removeAttribute('oo-rpt');

            this.owner = owner;
            this.evalFunction = Function('state', 'item', 'context', 'return (' + attrValue + ');').bind(this.owner);
            this.template = element.cloneNode(true);
            this.parentNode = element.parentNode;
            this.nextSibling = element.nextSibling;
            this.prevLength = 0,
            this.rows = [{
                boundElement: new boundElement(element, this.owner, true, 0),
                isInserted: false
            }];
        }

        refresh(parentContext) {
            this.evalCount = 1;
            
            let item = parentContext ? parentContext.item : null;
            let result = this.evalFunction(this.owner.state, item, parentContext);
            
            for(let i = 0; i < result.length; i++) {
                if(!this.rows[i]) {
                    this.rows[i] = {
                        boundElement: new boundElement(this.template.cloneNode(true), this.owner, true, i),
                        isInserted: false
                    };
                }

                this.evalCount += this.rows[i].boundElement.refresh({
                    parent: parentContext,
                    item: result[i],
                    index: i
                });

                if(!this.rows[i].isInserted) {
                    this.parentNode.insertBefore(this.rows[i].boundElement.element, this.nextSibling);
                    this.rows[i].isInserted = true;
                }
            }

            if(result.length < this.prevLength) {
                for(let i = result.length; i < this.prevLength; i++) {
                    this.rows[i].boundElement.element.remove();
                    this.rows[i].isInserted = false;
                }
            }

            this.prevLength = result.length;
            
            return this.evalCount;
        }
    }

    class ooElement extends HTMLElement {
        constructor(template) {
            super(); // always call super() first in the ctor.

            if(template) {
                this.attachShadow({ mode: 'open' });
                this.shadowRoot.appendChild(template.content.cloneNode(true));
                this.boundRoot = new boundElement(this.shadowRoot, this);
            }
        }

        setState(data) {
            this.state = data;
            this.boundRoot.refresh();
        }
    }
</script>