<script>
    (function(thisDoc) {
        let pattern = /{{\s*([^}]+)\s*}}/g;

        function generateFunctionExpressions(inputString) {
            let match;
            let lastIndex = 0;
            
            let strs = [];
            let funcs = [];
            
            while(match = pattern.exec(inputString)) {
                if(match.index !== lastIndex) {
                    strs.push(inputString.substring(lastIndex, match.index));
                }
                
                strs.push(null);
                funcs.push({
                    text: 'return (' + match[1] + ');',
                    index: strs.length - 1
                });
                
                lastIndex = match.index + match[0].length;
            }
            
            if(funcs.length > 0 && lastIndex < inputString.length) {
                strs.push(inputString.substring(lastIndex, inputString.length));
            }
            
            if(funcs.length > 0){
                return({
                    strs: strs,
                    funcs: funcs,
                });
            }

            return null;
        }


        customElements.define('o-o', class extends HTMLElement {
            constructor() {
                super();

                this.initialized = false;
                this.subControls = [];
            }

            static get observedAttributes() {
                return [
                    'prop',
                ];
            }

            setData(data) {
                this.data = data;

                if(!this.initialized)
                    this.initialize();

                var args = [];
                var argVals = [];
                var funcs = [];
                
                for(var prop in data) {
                    args.push(prop);
                    
                    if(typeof data[prop] === "function")
                    argVals.push(data[prop].bind(data));
                    else
                    argVals.push(data[prop]);
                }
                
                this.activeNodes.forEach(function(node){
                    var nodeModified = false;
                    var nodeStrs = Array.from(node.strs);
                    
                    node.funcs.forEach(function(func){
                    var funcArgs = Array.from(args);
                    funcArgs.push(func.text);
                    var myFunc = Function.apply(this, funcArgs);
                    
                    try {
                        nodeStrs[func.index] = myFunc.apply(data, argVals);
                    }
                    catch(err) {
                        console.log(err.message);
                    }
                    });
                    
                    var newStr = nodeStrs.join('');
                    if(newStr !== node.node.nodeValue) {
                    node.node.nodeValue = newStr;
                    console.log('Updated Node: ' + node.node.nodeValue);
                    }
                });

                this.subControls.forEach(function(control) {
                    var prop = control.getAttribute('prop');

                    if(prop)
                        control.setData(data[prop]);
                    else
                        control.setData(data);
                });
            }

            initialize() {
                this.activeNodes = [];

                var currentNode;

                var subNodes = this.subControls;

                var walker = document.createTreeWalker(
                    this,
                    NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT,
                    { acceptNode: function(node) {
                        if(node.nodeType === 3)
                            return NodeFilter.FILTER_ACCEPT;

                        if(node.tagName === 'O-O') {
                            subNodes.push(node);
                            return NodeFilter.FILTER_REJECT;
                        }
                            
                        return NodeFilter.FILTER_SKIP;
                    }
                },
                false);

                var numNodes = 0;
                var numChars = 0;

                while(currentNode = walker.nextNode()){

                    numNodes += 1;
                    numChars += currentNode.nodeValue.length;
                    /*
                    var pattern = /{{\s*([^}]+)\s*}}/g;
                    var match;
                    var lastIndex = 0;
                    
                    var strs = [];
                    var funcs = [];
                    
                    while(match = pattern.exec(currentNode.nodeValue)) {
                        if(match.index !== lastIndex) {
                        strs.push(match.input.substring(lastIndex, match.index));
                        }
                        
                        strs.push(null);
                        funcs.push({
                        text: 'return (' + match[1] + ');',
                        index: strs.length - 1
                        });
                        
                        lastIndex = match.index + match[0].length;
                    }
                    
                    if(funcs.length > 0 && lastIndex < currentNode.nodeValue.length) {
                        strs.push(currentNode.nodeValue.substring(lastIndex, currentNode.nodeValue.length));
                    }
                    */
                    var result = generateFunctionExpressions(currentNode.nodeValue);


                    if(result !== null){

                        result.node = currentNode;
                        this.activeNodes.push(result);
                        /*
                        this.activeNodes.push({
                        node: currentNode,
                        strs: strs,
                        funcs: funcs,
                        });
                        */
                    }
                }

                console.log('Nodes: ' + numNodes);
                console.log('Chars: ' + numChars);
                
                this.initialized = true;
            }
        });
    })(document.currentScript.ownerDocument);
</script>